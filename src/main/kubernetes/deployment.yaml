# Deployments exist to help manage the release of new versions of your application. 
# They transcend the application's 'version' and allow you to move easily from one version to another.
# Deployments support 'rollout' and 'zero-downtime' and can stop deployment if porblems occur.
# Deployments manage ReplicaSets.
# Recreate strategy updates the ReplicaSet with the new image and kills existing pods so that they get recreated (downtime).
# RollingUpdate updates the pods a few at a time while still receiving traffic so there's no downtime.
# maxUnavailable '25%' means that 25% of the pods will be lost and upgraded at a time.
# maxSurge '20%' means adding additional capacity temporarily and maintain the existing capacity for the rest of the rollout.
# Patterns: - maxSurge: 100% is effectively a blue/green deployment as 100% new pods are created and then old pods killed.
# Patterns: - maxUnavailable: 0% is essentially maintaining the existing capacity and only using surge capacity for the update

apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: mydeployment
  namespace: default
  labels:
    app: springboot-demo
spec:
  replicas: 3
  revisionHistoryLimit: 10
  minReadySeconds: 60 # wait until the first pod has been healthy for 60 seconds before rolling out the next one
  progressDeadlineSeconds: 300 # should take no more than 300 seconds per individual pod, otherwise fail the deployment.
  selector:
    matchLabels:
      app: springboot-demo
  strategy: # One of Recreate or RollingUpdate.
    rollingUpdate:
      maxSurge: 1 # adds additional pods temporarily so we can maintain our existing capacity (can be %)
      maxUnavailable: 1 # specifies how many pods can be killed and upgraded at a time (can be %).
    type: RollingUpdate
  template:
    metadata:
      annotations:
        kubernetes.io/change-cause: "Deploying to 0.0.1" # Update reason shows up in 'kubectl rollout history deployments xxx'
      labels:
        app: springboot-demo
        version: "0.0.1-SNAPSHOT" # This is just a label, changing it doesn't update the running version
    spec:
      containers:
      - name: springboot-demo
        image: benwilcock/pcf-springboot-demo:0.0.1-SNAPSHOT # You can change versions here
        imagePullPolicy: IfNotPresent # Can be 'Always' by default.
        ports:
        - containerPort: 8080
          protocol: TCP
        env: # Adds an ENV variable at runtime
          - name: MY_ENV_PARAMETER # Adds a specific ENV variable with the name 'MY_ENV_PARAMETER'.
            valueFrom: 
              configMapKeyRef: # Tells Kubernetes to get the ENV variable's value from a config-map key.
                name: myconfigmap # Takes the data from the Kubernetes registered config-map called `myconfig`.
                key: myparameter # Gives the variable the value associated with the key 'myparameter' in the config-map.
          - name: YOUR_HOST_IS
            valueFrom:
              configMapKeyRef:
                name: myconfigmap
                key: yourhostis
          - name: SPRING_PROFILES_ACTIVE
            valueFrom:
              configMapKeyRef:
                name: myconfigmap
                key: activeprofiles
          - name: VCAP_APPLICATION
            valueFrom:
              configMapKeyRef:
                name: myconfigmap
                key: vcapapplication
          - name: VCAP_SERVICES
            valueFrom:
              secretKeyRef:
                name: mysecret # Takes the data from the Kubernetes registered secret called `mysecret`
                key: vcap.services # Gives the variable the value assocuated with this key in the secret
          - name: DATABASE_USERNAME
            valueFrom:
              secretKeyRef:
                name: mysecret
                key: database.username
          - name: DATABASE_PASSWORD
            valueFrom:
              secretKeyRef:
                name: mysecret
                key: database.password
        volumeMounts:
          -  name: config-volume # We can also mount the same config-map as a disk volume if we like...
             mountPath: /config # The data in the config-map will appear under this mount path
      volumes:
        -  name: config-volume # Here we are creating the volume that is to be mounted
           configMap:
             name: myconfigmap # Here we are telling the volume to use the config-map 'myconfigmap' as the volume's contents
      # restartPolicy: never # Defaults to always